编译过程：
hello.c
            propressing (cpp) -> preprocessed (hello.i) -> compilation (gcc) -> assembly (hello.s)
stdio.h
--> assembly (as) --> obj files (hello.o) 
                                             --> Linking (ld) --> executable (a.out)
                      static library libc.a

source code -> scanner -> Tokens -> Parser -> Syntax Tree -> semantic analyzer -> commented syntax tree
-> source code optimizer -> intermediate representation -> code generator -> target code -> code optimizer
-> final target code

#预编译： 
gcc -E hello.c -o hello.i || cpp hello.c > hello.i
#编译：
gcc -S hello.i -o hello.s
预编译和编译合成一步：/usr/lib/gcc/i686-pc-linux-gnu/4.7.0/cc1 hello.c || gcc -S hello.c -o hello.s
汇编：as hello.s -o hello.o || gcc -c hello.s -o hello.o
预编译，编译和汇编合成一步：gcc -c hello.c -o hello.o
链接：ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i686-linux-gnu/4.7.0/crtbeginT.o -L/usr/lib/gcc/i686-linux-gnu/4.7.0 -L/usr/lib -L/lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i686-linux-gnu/4.7.0/crtend.o /usr/lib/crtn.o
ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o

自定义段：
__attribute__((section("FOO"))) int global=42;
__attribute__((section("BAR"))) void foo()
{
}

.data保存了初始化了的全局静态变量和局部静态变量
.rodata保存了只读数据，一般是const修饰变量和字符串常量
.bss段存放未初始化的全局变量和局部静态变量。有些编译器会将
全局未初始化变量放在.bss里，有些则是预留一个未定义的全局变量符号
等到最终链接时再放入.bss段。编译单元内的可见静态变量是放在
.bss段的

static int x1 = 0;
static int x2 = 1;
因为x1初始化为0,可认为没有初始化，所以放在.bss段，不占空间
而x2确实初始化为1,因此放在.data段


链接器使用两步链接：
第一步：空间与地址分配： 扫描所有的输入目标文件，并获取他们各个段长度，属性和位置，
并且将输入目标文件中的符号表中所有符号定义和符号引用收集起来，统一放在
一个全局符号表，这一步中，链接器将能够获得所有输入目标文件的段长度，并将他们合并，计算出文件中各个段合并后的长度和位置，并
建立映射关系。
第二步：符号解析与重定位：读取输入文件中的段的数据，重定位信息，并进行
符号解析与重定位，调整代码中的地址。

符号地址的确定：
第一步的扫描和空间分配，链接器按照上述方法进行分配，那么这时各段在链接后的虚拟地址就确定了，然后根据各符号在各段内偏移调整地址


重定位：
OFFSET TYPE VALUE
指令修成方法：

crt1.o: __start, hlt
crti.o: _init, _fini
crtbegin.o: __do_global_dtors_aux, frame_dummy, .fini .init
crtend.o: __do_global_ctors_aux, .init

ld crt1.o crti.o [user_objs] [system_libraries] crtn.o



弱符号和弱引用：库中定义的弱符号可以被用户定义的强符号所覆盖，从而使程序
使用自定义版别的库函数，或者程序可以对某些扩展功能模块的应用定义为弱引用，
当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用。如果去掉某些功能，
那么程序可以正常链接。

#include <stdio.h>
#include <pthread.h>
int pthread_create(pthread_t *, 
        const pthread_attr_t*,
        void * (*) (void *),
        void *) __attribute__ ((weak));
int main ()
{
    if (pthread_create) {
        printf ("This is multi-thread version\n");
    } else {
        printf ("This is single-thread version\n");
    }
}
